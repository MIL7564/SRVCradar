***Codebase:

**AndroidManifest.xml:-
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools">

    <uses-permission android:name="android.permission.INTERNET" />
    <uses-permission android:name="android.permission.READ_SMS" />
    <uses-permission android:name="android.permission.RECEIVE_SMS" />

    <uses-permission android:name="android.permission.RECEIVE_BOOT_COMPLETED" />

    <uses-feature android:name="android.hardware.telephony" android:required="false" />
    <uses-feature android:name="android.hardware.faketouch" android:required="false" />

    <application
        android:allowBackup="true"
        android:dataExtractionRules="@xml/data_extraction_rules"
        android:fullBackupContent="@xml/backup_rules"
        android:icon="@mipmap/ic_launcher"
        android:label="@string/app_name"
        android:roundIcon="@mipmap/ic_launcher_round"
        android:supportsRtl="true"
        android:theme="@style/Theme.Retriever"
        tools:targetApi="33">

        <service android:name=".MessageMonitoringService" android:exported="false"/>

        <receiver
            android:name=".BootReceiver"
            android:enabled="true"
            android:exported="true"
            android:permission="android.permission.RECEIVE_BOOT_COMPLETED">
            <intent-filter>
                <action android:name="android.intent.action.BOOT_COMPLETED" />
                <category android:name="android.intent.category.DEFAULT" />
            </intent-filter>
        </receiver>

        <receiver android:name=".SMSReceiver" android:exported="true" android:permission="android.permission.BROADCAST_SMS">
            <intent-filter>
                <action android:name="android.provider.Telephony.SMS_RECEIVED" />
            </intent-filter>
        </receiver>

        <activity android:name=".MainActivity" android:exported="true">
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />
                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>
        </activity>

        <!-- Other elements in the manifest file -->

    </application>

</manifest>

**SMSReceiver.java:-
package com.text.retriever;

import java.io.IOException;
import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.os.AsyncTask;
import android.os.Build;
import android.os.Bundle;
import android.telephony.SmsMessage;
import android.util.Log;
import okhttp3.MediaType;
import okhttp3.OkHttpClient;
import okhttp3.Request;
import okhttp3.RequestBody;
import okhttp3.Response;

import java.util.concurrent.TimeUnit;

public class SMSReceiver extends BroadcastReceiver {
    private static final String TAG = "SMSReceiver";
    private OkHttpClient client;
    private static final String WEBHOOK_URL = "https://FlowerEconomics.com/wp-json/my-webhooks/v1/webhook/text";  // replace this with your actual URL
    private static final MediaType JSON = MediaType.get("application/json; charset=utf-8");

    public SMSReceiver() {
        this.client = new OkHttpClient.Builder()
                .connectTimeout(20, TimeUnit.SECONDS)
                .readTimeout(20, TimeUnit.SECONDS)
                .build();
    }


    @Override
    public void onReceive(Context context, Intent intent) {
        if ("android.provider.Telephony.SMS_RECEIVED".equals(intent.getAction())) {
            Bundle extras = intent.getExtras();
            if (extras != null) {
                Object[] pdus = (Object[]) extras.get("pdus");
                if (pdus != null && pdus.length > 0) {
                    SmsMessage[] messages = new SmsMessage[pdus.length];
                    for (int i = 0; i < pdus.length; i++) {
                        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
                            String format = extras.getString("format");
                            messages[i] = SmsMessage.createFromPdu((byte[]) pdus[i], format);
                        } else {
                            messages[i] = SmsMessage.createFromPdu((byte[]) pdus[i]);
                        }
                    }

                    // Extract necessary information from the messages
                    String messageBody = messages[0].getMessageBody();
                    String sender = messages[0].getOriginatingAddress();

                    // Convert the message body and keywords to lowercase for case-insensitive comparison
                    String lowerCaseMessageBody = messageBody.toLowerCase();
                    String keyword1 = "cellnet";
                    String keyword2 = "opa";

                    if (lowerCaseMessageBody.contains(keyword1) && lowerCaseMessageBody.contains(keyword2)) {
                        // Keywords "cellnet" and "opa" (case-insensitive) found in the message
                        // Log the entire message and sender's number (second, third, and fourth digits)
                        Log.i(TAG, "SMS contained the word 'cellnet' and 'opa': " + messageBody);
                        if (sender != null && sender.length() > 4) {
                            Log.i(TAG, "Sender's number, digits Two TO Four: " + sender.substring(1, 4));
                            // Trigger the webhook asynchronously using AsyncTask
                            // new WebhookAsyncTask().execute(escapeJsonString(messageBody), sender.substring(1, 4));
                            WebhookAsyncTask escapeJsonString = new WebhookAsyncTask();
                            escapeJsonString.execute(messageBody, sender.substring(1,4));
                        } else {
                            Log.w(TAG, "Sender's number is not long enough to extract digits Two TO Four");
                        }
                    }
                }
            }
        }
    }


    public class RunPythonFromJava {
        public String getPythonOutput() {
            String pythonScriptPath = "../../../../../python/dispenser.py"; // Replace with the actual path
            String output = "";

            try {
                // Create a ProcessBuilder to run the Python script
                ProcessBuilder processBuilder = new ProcessBuilder("python", pythonScriptPath);
                processBuilder.redirectErrorStream(true);
                Process process = processBuilder.start();

                java.io.InputStream inputStream = process.getInputStream();
                java.util.Scanner scanner = new java.util.Scanner(inputStream).useDelimiter("\\A");
                output = scanner.hasNext() ? scanner.next() : "";

                int exitCode = process.waitFor();
                Log.i(TAG, "Python process exited with code: " + exitCode);
            } catch (IOException | InterruptedException e) {
                e.printStackTrace();
            }

            return output;
        }
    }


    private class WebhookAsyncTask extends AsyncTask<String, Void, Void> {
        @Override
        protected Void doInBackground(String... params) {
            String messageBody = params[0];
            String fromNumber = params[1];

            // Get Python script output
            RunPythonFromJava pythonRunner = new RunPythonFromJava();
            String TICKET = pythonRunner.getPythonOutput().trim();

            try {
                String requestBody = "{\"text\":\"" + messageBody + "\",\"FromNumber\":\"" + fromNumber + "\"}";
                RequestBody body = RequestBody.create(requestBody, JSON);
                Request request = new Request.Builder()
                        .url(WEBHOOK_URL)
                        .post(body)
                        .addHeader("Content-Type", "application/json")
                        .addHeader("FromNumber", fromNumber)
                        .addHeader("text", messageBody)
                        .addHeader("TICKET", TICKET) // Add TICKET as a header
                        .build();

                // Execute the request
                Response response = client.newCall(request).execute();

                Log.i(TAG, "Webhook response: " + response.body().string());
            } catch (Exception e) {
                Log.e(TAG, "Error in sending request", e);
            }

            return null;
        }
    }

}

**dispenser.py:-
# dispenser.py

import time
# import csv


# Get current time in nanoseconds since the epoch
current_time_ns = time.time_ns()

print(f"Current time in nanoseconds since the epoch: {current_time_ns}")

# If you want to convert this to a more human-readable format:
from datetime import datetime

current_datetime = datetime.fromtimestamp(current_time_ns / 1e9)
# print(f"Human-readable format: {current_datetime}")

# Note: The human-readable format won't show the nanoseconds, but the precision is still stored in the variable.

# Write to CSV file
# csv_filename = "current_datetime.csv"
# with open(csv_filename, 'w', newline='') as csvfile:
#    csv_writer = csv.writer(csvfile)
#    csv_writer.writerow(['timestamp', 'human_readable'])
#    csv_writer.writerow([current_time_ns, current_datetime])

# print(f"Current time in nanoseconds since the epoch: {current_time_ns}")
# print(f"Human-readable format: {current_datetime}")
# print(f"Data exported to {csv_filename}")

**my-webhooks.php:-
<?php
/*
Plugin Name: My Webhooks
Description: Custom plugin to handle incoming webhooks from Mobilephones.
Requisites: "WP REST API" plugin and "League Table Grid" plugin.
Version: 0.0.9
Delicensed: CC0 by Salman SHUAIB
*/

include 'CitiesBank.php';
$areaCodeToCity = array_flip($cityAreaCodes);  // Reverse the array for lookup


if (!function_exists('resolute')) {
    function resolute($phNum) {
        $digits = str_split($phNum);
        while (count($digits) > 1) {
            $digits = str_split(array_sum($digits));
        }
        return intval($digits[0]);
    }
}

// Webhook handler function
if (!function_exists('handle_webhook_request')) {
    function handle_webhook_request(WP_REST_Request $request) {
        global $areaCodeToCity;

        // Extract the necessary information from the request headers
        $from_number = $request->get_header('FromNumber');
        $text = $request->get_header('text');
        $TICKET = $request->get_header('TICKET');

        $legion_num = resolute($from_number);

        // Extract the area code from the phone number
        $areaCode = substr($from_number, 0, 3);  // Assuming the area code is the first three digits

        $baseCity = $areaCodeToCity[$areaCode] ?? "{Tag: BASECITY}";  // Check if the area code exists, else default

        update_option('legion_number', $legion_num);       
        // Perform actions based on the webhook data
        // Create a new post with the received data
        $post_data = array(
            'post_title'   => $baseCity . ' ' . $TICKET,
            'post_content' => $text,   
            'post_status'  => 'publish',
            'post_author'  => 2, 
            //'post_category' => $sub_category
        );

        $post_id = wp_insert_post($post_data);
        
        global $wpdb;
        $wpdb->update(
            $wpdb->posts,
            array(
                'legion_number' => $legion_num  
            ),
            array('ID' => $post_id) 
        );
        
        // Check for duplicates and trash if necessary
        do_action('interdict_check_duplicate', $post_id, $from_number);

        // Send a response if necessary
        if ($post_id) {
            // Post created successfully
            return new WP_REST_Response('Post created', 200);
        } else {
            // Error occurred while creating the post
            return new WP_REST_Response('Error creating post', 500);
        }
    }
}

// Register the custom webhook route
function register_custom_webhook_route() {
    register_rest_route('my-webhooks/v1', '/webhook/text', array(
        'methods' => 'POST',
        'callback' => 'handle_webhook_request',
    ));
}

// Ensure the callback to register_custom_webhook_route is being run
add_action('rest_api_init', 'register_custom_webhook_route');
?>